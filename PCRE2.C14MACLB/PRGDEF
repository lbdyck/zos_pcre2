         MACRO
&LABEL   PRGDEF &FSEG=,&REXX=N,&AMODE=31,&RMODE=ANY,&INREX=N,          /
               &RENT=N,&MAXSEG=50,&SBAS2=N,&SBAS3=N,&MAXPAR=24,        /
               &RBAS2=N,&RBAS3=N,&RLOC=ANY,&WTOL=80
.*
.*  Created by John Gateley
.*
.*  This macro defines the start ot the program and is responsible
.*  for getting and releasing dynamic storage if RENT=Y is specified.
.*  RBAS2 and RBAS3 provide for additional reentrant storage
.*  base registers.
.*  SBAS2 and SBAS3 provide for additional static storage base
.*  registers.
.*
.*  The assembler LOCTR is used to build the object module with the
.*  static variables such as literals and constants at the top followed
.*  by the executable code. Code in the program should be segmented
.*  using SEGS and SEGE macros and segments should be performed by use
.*  of the SEGDO macro. A code base register is used to give
.*  addressability within each segment and is automatically
.*  maintained on entry to and exit from a segment. Branching to a
.*  label in another segment will usually cause an 'interesting' abend.
.*
.*  Example program layout
.*
.*   TITLE 'PROGRAM TITLE'
.*  NAME  PRGDEF FSEG=MAIN_BIT,REXX=Y,RENT=Y
.*  DYNAMIC_STORAGE_VARIABLE   DS    F
.*        PRGEDEF
.*   SEGS MAIN_BIT
.*     MVC   ....
.*     SEGDO SEGMENT_TWO
.*   SEGE MAIN_BIT
.*   SEGS SEGMENT_TWO
.*     MVC   ....
.*   SEGE SEGMENT_TWO
.*
.*        PRGSTAT
.*  A_CONSTANT   DC    C'SOME TEXT'
.*        PRGESTAT
.*        PRGEND
.*        END
.*
.*  An area of re-entrant storage called MESS_TXT is provided and is
.*  used by the WTOX macro to write to operator, this defaults to
.*  80 but can be up to 120 and is set by WTOL=80.
.*  An area is provided for building parameter lists MY_PARM the
.*  number of fullwords is set by MAXPAR=24.
.*  REXX=Y automatically includes the macros required for writing
.*  rexx functions in assembler. INREXX=Y is for rexx functions
.*  that are not called directly by rexx.
.*
.*  Registers used are
.*             R13            save area and base for re-entrant
.*                            storage between PRGDEF and PRGEDEF
.*             R12            base register for static variables which
.*                            are defined between PRGSTAT and PRGESTAT
.*             R11            segment code base register
.*             R10            rexx environment block
.*             R9             rexx EFPL
.*             R8             rexx ARGTABLE_ENTRY
.*             R7             rexx EVALBLOCK
.*
.*  Defaults are
.*             RENT=NO
.*             CBASE=R11      Code base register set in every segment
.*             AMODE=31
.*             RMODE=ANY
.*             MAXSEG=50      Maximium number of segments in program
.*             SBAS2=N        No second storage register
.*             SBAS3=N        No third storage register
.*             RBAS2=N        No second reentrant register
.*             RBAS3=N        No third reentrant register
.*             MAXPAR=24      Parameter list length
.*             WTOL=80        80 character message area.
.*
           GBLC  &MODNAME
           GBLC  &SETREX
           GBLC  &INREXX
           GBLC  &ISRBAS2,&ISRBAS3
           GBLC  &ISSBAS2,&ISSBAS3
           GBLC  &SEGSAVA
           GBLC  &BASSAVA
           GBLC  &SAMODE
           GBLC  &ISRENT
           GBLC  &SCBASER
           GBLC  &STRWRK
           GBLA  &SEGCNT
           GBLA  &SEGMAX
           GBLA  &PARMAX
           GBLA  &SCBASEC
           GBLA  &WHICHM
           LCLA  &CNT1,&CNT2
           AIF   ('&LABEL' EQ '').MNOTE1
           AIF   ('&FSEG' EQ '').MNOTE2
.*
*   Change branch link to branch save, ensure clean 31 bit addresses
BAL        OPSYN BAS
BALR       OPSYN BASR
.*
&MODNAME   SETC  '&LABEL'
&ISRBAS2   SETC  '&RBAS2'
&ISRBAS3   SETC  '&RBAS3'
&ISSBAS2   SETC  '&SBAS2'
&ISSBAS3   SETC  '&SBAS3'
&ISRENT    SETC  '&RENT'(1,1)
&SAMODE    SETC  '&AMODE'
&SETREX    SETC  '&REXX'(1,1)
&INREXX    SETC  '&INREX'(1,1)
&SCBASER   SETC  'R11'
&STRWRK    SETC  '#STRING_WORK'
&SEGCNT    SETA  0
&SCBASEC   SETA  0
&SEGMAX    SETA  &MAXSEG
&PARMAX    SETA  &MAXPAR
&CNT1      SETA  1
&CNT2      SETA  &PARMAX
&WHICHM    SETA  5
*
&MODNAME   START 0
           AIF   ('&AMODE' EQ '31').ABIT31
           AIF   ('&AMODE' NE '24').MNOTE3
.ABIT24    ANOP
&MODNAME   AMODE 24
&MODNAME   RMODE 24
           AGO   .AFTR
.ABIT31    ANOP
&MODNAME   AMODE 31
           AIF   ('&RMODE' EQ '24').RBIT24
           AIF   ('&RMODE' EQ 'ANY').RBIT31
           AGO   .MNOTE4
.RBIT24    ANOP
&MODNAME   RMODE 24
           AGO   .AFTR
.RBIT31    ANOP
&MODNAME   RMODE ANY
.AFTR      ANOP
*
R0         EQU   0
R1         EQU   1
R2         EQU   2
R3         EQU   3
R4         EQU   4
R5         EQU   5
R6         EQU   6
           AIF   ('&SETREX' EQ 'Y').REXEQ
           AIF   ('&INREXX' EQ 'Y').REXEQ
R7         EQU   7
R8         EQU   8
R9         EQU   9
R10        EQU   10
           AGO   .REXEQX
.REXEQ     ANOP
R7         EQU   7                   * rexx EVALBLOCK
R8         EQU   8                   * rexx ARGTABLE_ENTRY
ARG_POINT  EQU   8                   * rexx ARGTABLE_ENTRY alt name
R9         EQU   9                   * rexx EFPL
R10        EQU   10                  * rexx ENVBLOCK
.REXEQX    ANOP
R11        EQU   11                  * segment base register
R12        EQU   12                  * module base register
R13        EQU   13                  * reentrant storage
R14        EQU   14
R15        EQU   15
.*
           AIF   ('&SETREX' EQ 'N').NOREX1
           AIF   ('&INREXX' EQ 'Y').MNOTE5
.NOREX1    ANOP
*
           BRUL  BEGIN
*
@DATA      LOCTR ,
           DC    CL10' &MODNAME'
&AADAT     SETC  '&SYSCLOCK'(1,19)
           DC    CL20'&AADAT'
           DC    CL48'Copyright (C) ------------------------'
           DS    0F
@CODE      LOCTR ,
BEGIN      DS    0H
           STM   R14,R12,12(R13)     * save registers in caller
           LARL  R12,&MODNAME        * get address of entry point
*
           AIF   ('&ISSBAS2' EQ 'N').NOS2BAS
           AIF   ('&ISSBAS3' EQ 'N').NOS3BAS
*
           USING &MODNAME,R12
           LA    &ISSBAS2,2048(,R12)
           LA    &ISSBAS2,2048(,&ISSBAS2)
           USING &MODNAME+4096,&ISSBAS2
           LA    &ISSBAS3,2048(,&ISSBAS2)
           LA    &ISSBAS3,2048(,&ISSBAS3)
           USING (&MODNAME+8192,BEGIN),&ISSBAS3
           AGO   .ENDSTAT
*
.NOS3BAS   ANOP
           USING &MODNAME,R12
           LA    &ISSBAS2,2048(,R12)
           LA    &ISSBAS2,2048(,&ISSBAS2)
           USING (&MODNAME+4096,BEGIN),&ISSBAS2
           AGO   .ENDSTAT
*
.NOS2BAS   ANOP
           USING (&MODNAME,BEGIN),R12
.ENDSTAT   ANOP
*
           LR    R9,R1               save parameter address
           AIF   ('&SETREX' EQ 'N').NO0001
           LR    R10,R0              save rexx environment block addr
.NO0001    ANOP
           AIF   ('&ISRENT' EQ 'Y').RNT001
*    Note that save area is NOT re-entrant
           LARL  R2,#RENT_AREA
           AGO   .RNT002
.RNT001    ANOP
*    Note that save area is re-entrant
           L     R2,#RENTSIZ
           AIF   ('&RLOC' NE 'ANY').SBIT24
           AIF   ('&AMODE' EQ '31').SBIT31
.SBIT24    ANOP
*          STORAGE OBTAIN,LENGTH=(R2),LOC=24
           CNOP  0,4
           BRAS  R15,#GET_LAB
           DC    BL1'00000000'
           DC    AL1(0*16)
           DC    AL1(0)
           DC    BL1'00010010'
#GET_LAB   DS    0F
           LR    0,R2
           L     15,0(,R15)
           L     14,16(0,0)
           L     14,772(14,0)
           L     14,160(14,0)
           PC    0(14)
           AGO   .ESTOR
.SBIT31    ANOP
*          STORAGE OBTAIN,LENGTH=(R2),LOC=31
           CNOP  0,4
           BRAS  R15,#GET_LAB
           DC    BL1'00000000'
           DC    AL1(0*16)
           DC    AL1(0)
           DC    BL1'01110010'
#GET_LAB   DS    0F
           LR    0,R2
           L     15,0(,R15)
           L     14,16(0,0)
           L     14,772(14,0)
           L     14,160(14,0)
           PC    0(14)              get storage
.ESTOR     ANOP
           LR    R2,R1               copy storage address
.RNT002    ANOP
           LR    R1,R9               restore parameter address
           ST    R13,4(R2)           chain save areas
           ST    R2,8(R13)
           LR    R13,R2
*
           AIF   ('&ISRBAS2' EQ 'N').NOR2BAS
           AIF   ('&ISRBAS3' EQ 'N').NOR3BAS
*
           USING #PRGAREA,R13
           LA    &ISRBAS2,2048(,R13)
           LA    &ISRBAS2,2048(,&ISRBAS2)
           USING &PRGAREA+4096,&ISRBAS2
           LA    &ISRBAS3,2048(,&ISRBAS2)
           LA    &ISRBAS3,2048(,&ISRBAS3)
           USING (#PRGAREA+8192,#E_RENT),&ISRBAS3
           AGO   .ENDRTAT
*
.NOR3BAS   ANOP
           USING #PRGAREA,R13
           LA    &ISRBAS2,2048(,R13)
           LA    &ISRBAS2,2048(,&ISRBAS2)
           USING (#PRGAREA+4096,#E_RENT),&ISRBAS2
           AGO   .ENDRTAT
*
.NOR2BAS   ANOP
           USING (#PRGAREA,#E_RENT),R13
.ENDRTAT   ANOP
*
           AIF   ('&SETREX' EQ 'N').NO0002
           LR    R0,R10              restore environment block address
.NO0002    ANOP
.*
           AIF   ('&SETREX' EQ 'N').NOREX2
           USING ENVBLOCK,R10        use environment block
           USING EFPL,R9
           L     R8,EFPLARG
           USING ARGTABLE_ENTRY,R8
           L     R7,EFPLEVAL
           L     R7,0(R7)
           USING EVALBLOCK,R7
           STM   R7,R10,#SAV_REX
           XC    EVALBLOCK_EVLEN,EVALBLOCK_EVLEN
.NOREX2    ANOP
           AIF   ('&INREXX' NE 'Y').NOINREX
           L     R9,4(R13)
           MVC   #SAV_REX(4*4),#SAV_REX-#PRGAREA(R9)
           LM    R7,R10,#SAV_REX
           USING ENVBLOCK,R10
           USING EFPL,R9
           USING ARGTABLE_ENTRY,R8
           USING EVALBLOCK,R7
.NOINREX   ANOP
.*
           XC    R_C,R_C
           XC    MY_PARM(LEN_MY_PARM),MY_PARM
           STMH  R0,R15,#HIGH_HALF         * save high registers
           AIF   ('&ISRENT' NE 'Y').RNT003
*    initialise obtained storage to low-values if reentrant
           L     R15,#RENTSIZ              * length of reentrant area
           AR    R15,R13                   * start of area
           LA    R14,MY_PARM
           SR    R15,R14
           LR    R2,R1
           XR    R1,R1
           MVCL  R14,R0                    * wipe to low values
           LR    R1,R2                     * restore PARM address
.RNT003    ANOP
*
.*
.*       area for use by the WTOX macro the length of the message
.*       is set by macro parameter &WTOL which defaults to 80
.*       permitted values are 80 to 120
.*
&A         SETA  &WTOL                     * copy length
           AIF   (&A LT 80).MNOTE6
           AIF   (&A GT 120).MNOTE6
           MVC   #MESS_LEN,=H'&WTOL'       * set length of WTO text
           MVI   MESS_TEXT,C' '
           MVC   MESS_TEXT+1(L'MESS_TEXT-1),MESS_TEXT
.*
*          copy list form WTO expansion from PRGSTAT static storage
.*
           MVC   #ACT_WTO_LIST(L_#PTN_WTO_LIST),#PTN_WTO_LIST
*
           ST    R1,#PARM_ADDR             * save input PARM address
*
           BRAS  R14,##&FSEG               * go to main code
*
           BRU   #AFT_RENT                 * go to clean up
*
           DS    0F
*
&SEGSAVA   SETC  '#SEG_SAV'
.*
           AIF   ('&ISRENT' EQ 'Y').RNT004
#PRGAREA       DSECT                       * DSECT overlays #RENT_AREA
           AGO   .RNT005
.RNT004    ANOP
#PRGAREA       DSECT                       * DSECT overlays getmained
.RNT005    ANOP
#SAVAREA       DS    18F
#SAV_REX       DS    4F
#SEG_SAV       DS    &SEGMAX.F             * segment save area
               AIF   ('&SCBASER' EQ 'N').NOCBAS
#BAS_SAV       DS    &SEGMAX.F             * segment base reg save
&BASSAVA       SETC  '#BAS_SAV'
.NOCBAS        ANOP
R_C            DS    F
*
DOUB_WORD      DS    D
MY_PARM        DC    &PARMAX.F'0'          * define call parm area
               ORG   MY_PARM
.PLOOP         ANOP
MY_P_&CNT1     DS    F
&CNT1          SETA  &CNT1+1
               AIF   (&CNT1 LE &CNT2).PLOOP
.*
END_MY_PARM    EQU   *
LEN_MY_PARM    EQU   *-MY_PARM
#MVCLSAV       DC    4F'0'
#HIGH_HALF     DS    16F                   * high half of registers
LEN_SAY        DS    F
#PARM_ADDR     DS    F                     * contents of R1 on entry
HEXPACK_W2     DS    CL2                   * used in XPACK macro
HEXPACK_W3     DS    CL3                   * used in XPACK macro
#STRING_WORK   DS    CL32                  * used in STRING macro
#ACT_WTO_LIST  DS    CL(L_#PTN_WTO_LIST)   * area for WTOX macro
#MESS_LEN      DS    H                     * WTOX length
MESS_TEXT      DS    CL&WTOL               * WTOX text
               ORG   MESS_TEXT
MESS_TXT       DS    CL&WTOL               * WTOX text alternate name
*
         MEXIT
.MNOTE1  MNOTE 16,'The program name was not specified in column 1'
         MEXIT
.MNOTE2  MNOTE 16,'FSEG parameter was not specified'
         MEXIT
.MNOTE3  MNOTE 16,'AMODE not = 31 or 24'
         MEXIT
.MNOTE4  MNOTE 16,'RMODE not = ANY or 24'
         MEXIT
.MNOTE5  MNOTE 16,'REXX=YES and INREX=YES are mutually exclusive'
         MEXIT
.MNOTE6  MNOTE 16,'WTOL= permitted values are between 80 and 120'
         MEND
