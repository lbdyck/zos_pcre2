PCRE2 Native z/OS Port
----------------------
Copyright  © 2012 - 2019 Ze'ev Atlas
Copyright  © 2017 - 2019 John Gateley [for the Rexx API.]

PCRE2 version 10.35 2020-05-09
Compiled with
  EBCDIC code support: LF is 0x15
  EBCDIC code page IBM1140 or similar
  8-bit support
  No Unicode support
  No just-in-time compiler support
  Default newline sequence is LF
  \R matches all Unicode newlines
  \C is supported
  Internal link size = 2
  Parentheses nest limit = 250
  Default heap limit = 20000000 kibibytes
  Default match limit = 10000000
  Default depth limit = 10000000
  pcre2test has neither libreadline nor libedit support

What's new
----------
10.35
This is a maintenance release:
Bugfixes, tidies, and a few new enhancements.
1. Capturing groups that contain recursive backreferences to themselves
  are no longer automatically atomic, because the restriction is no
  longer necessary as a result of the 10.30 restructuring.
2. Several new options for pcre2_substitute().

The z/Os version is now clean.  Both LE and Rexx API work smoothly.

10.34a
This interim release represents some changes in the z/OS side while
the core PCRE2 library is unchanged.

Fixed some bugs in the z/OS specific functions:
    pcrz_space_to_null_term_str  ZSPC2NUL
    pcrz_null_to_space_term_str  ZNUL2SPC
These bugs produced an incorrect length that was the root cause of the
bug mentioned in 10.33 that had been incorrectly attributed to the
COBOL program.

Brought some of the COBOL copybooks up to date.

Added a demo program to demonstrate the usage of
pcre2_substitute  SUBSTIT2
Please see some additional, COBOL specific documetation in the COB
library.

Added the substitute functionality to the Rexx API.  Please see the
Modified Rexx API documentation herein and in the ASM library.

Added three more functions to deal with conversion back and forth
between IBM-1047 and user's codeset to help with the substitute
functionality:
    pcrz_codeset_init_substitute              ZCSINIS
    pcrz_codeset_convert_replacement          ZCSCONVR
    pcrz_codeset_convert_substitute_back      ZCSCONVB

10.34
There is nothing new in the z/OS port.

Non-atomic positive lookarounds are implemented in the pcre2_match()
interpreter, but not in JIT (i.e. it is included in the z/OS port.)

10.33
As usual, see ChangeLog for full details of changes.

Of note are changes in pcre2test, implementation of Perl 5.28
experimental alphabetic names for atomic groups and lookaround
assertions and many other fancy changes.

Apperently, fixed two typos in EBCDIC special handling for ranges such
as a-z in EBCDIC environments. The original code probably never worked,
though there were no bug reports.  I must admit that it wasn't me who
caught the issue.

I have fixed a bug in the PCOBDEM2 program that caused a perfect match
to be ignored if it coincided with the end of the subject string.

I have got a wind that IBM is actually working on a JIT version of
PCRE2, but in the Linux context with no immediate plans for EBCDIC.
I assume that they would eventually deal with EBCDIC, but native z/OS
does not seem to be a priority.

The most significant change was something that I had dealt with in the
z/OS port, assuming that all other implementations do not have that
issue.  Many z/OS programmers may not have any say on the order in
which the link libraries are ordered and using the POSIX names regcomp,
regexec, regerror and regfree in PCRE2 context may bind to the wrong
instance.  I used alternative names and it so happened that The Debian
implementation had similar solution.
The POSIX functions are now all called pcre2_regcomp() etc., with
wrapper functions that use the standard POSIX names. However, in
pcre2posix.h the POSIX names are defined as macros. This should help
avoid linking with the wrong library in some environments while still
exporting the POSIX names for pre-existing programs that use them. (The
Debian alternative names are also defined as macros, but not
documented.)
This change required some work on my side, to undo my special handling
while preserving my alternative names for whomever was using them.
On one hand PC2PSXAP.h was simplified with no need for special #pragma.
On the other hand PCOBAPI2.C now provides support for my alternative
names.  However, for any new implementation my alternative names are
deprecated and should not be used!  Instead, use the POSIX names and
PC2PSXAP.h header and provide DEF(COMPILE_WITH_PCRE2) as compile option
if you want the PCRE2 version

10.32
This is mainly a bugfix and tidying release (see ChangeLog for full
details).  However, there are some minor enhancements.
There are no real changes on the z/OS side as well except of an
important bugfix.  There was a bug in the TRIMIT macro and some
changes in some other macros.

Users of the REXX API should use the new version of that API to
benefit from the aforementioned bugfix

10.31
This is mainly a bugfix and tidying release (see ChangeLog for full
details).  However, there are some minor enhancements.
In the z/OS side we have some development that continue in the interim
release spirit.
I have started an effort to put my scripts, those that do the porting,
in GIT-HUB.  Unfortunately, due to sickness in the family, I did not
have time to finish that.  You may find the incomplete (and somewhat
older version) in https://github.com/zatlas1/PCRE2forZOS.  I hope to
finalize that effort for the next release.  I do not intnd to abandon
the CBTTAPE distribution venue as it is geared towards EBCDIC files in
XMI format.  The GIT-HUB is more for the behind the scene porting
effort, while CBTTAPE is more for the final product.

1. John Gateley and I were busy introducing the second version of the
   REXX API.  The first version was pretty much experimental, while
   the current version is more general and allows reuse of compiled
   patterns.

   Remember that the Rexx API provide access to the main functionality
   of PCRE2 (i.e. pattern matching) but it hides all the gory details
   and thus do not give access to all the library flexibility and
   options.  Also, by not persisting the environment (it does not use
   CEEPIPI), usage of the library for heavy load could be expensive as
   every call repeats the pattern compile process.

2. While developing that API we have come to fully understand the
   effects of what I call the EBCDIC horror on using EBCDIC in any
   generalized coherent way.  To counter those effects I've developed
   an interface to IBM's iconv() function.  This interface aims to
   hide the gory details as much as possible away from the user.
   This interface is distributed as part of the package and is fully
   implemented in the REXX API.

3. Several sections of this document were incorrect or misleading
   because of the lack of full understanding of the EBCDIC horror.  I
   tried to find all those sections and rewrite or update them.
   However I ask anybody to point me to any error, unclear explanation,
   typo, inconsistency or bad style that might be present in this
   document and I promise to do my best to correct or improve in the
   next release.

4. This was available since 10.30:
   The main interpreter, pcre2_match(), has been refactored into a new
   version that does not use recursive function calls (and therefore
   the system stack) for remembering backtracking positions. This makes
   --disable-stack-for-recursion a NOOP. The new implementation allows
   backtracking into recursive group calls in patterns, making it more
   compatible with Perl, and also fixes some other previously
   hard-to-do issues. For patterns that have a lot of backtracking, the
   heap is now used, and there is explicit limit on the amount,
   settable by pcre2_set_heap_limit() or (*LIMIT_HEAP=xxx). The
   "recursion limit" is retained, but is renamed as "depth limit"
   (though the old names remain for compatibility).

   There is also a change in the way callouts from pcre2_match() are
   handled. The offset_vector field in the callout block is no longer a
   pointer to the actual ovector that was passed to the matching
   function in the match data block. Instead it points to an internal
   ovector of a size large enough to hold all possible captured
   substrings in the pattern.

5. We now take compatibility issues into account and compile the C and
   assembler in fairly low hardware level.

6. I have not yet developed PL/I 'include' modules similar to the
   available COBOL copybooks.  Being that C is an LE language, the
   library functions could be called from PL/I.  What is not provided
   are the structures used by the functions and the equivalent of the
   pcre2.h header.

7. Sharp-eyed users would notice a new component in both the SRCE and
   LOADLIB libraries: EXTUNI2 (pcre2_extuni.c).  This component is part
   of what is defined to the automated process as needed.  However, in
   reality this component is not needed.  It will be removed on the
   next release.

A lot of thanks to John Gateley who worked on the Rexx interface and
incorporated the dealing with code pages in it.

Machine and z/OS compatibility
------------------------------
As I became more aware about compatibility issues, the distributed
library would be catered to somewhat older combination of hardware and
OS, older than the current IBM latest.  Since the distribution contains
the source code and JCL, one could compile for the latest and greatest
or conversly for an older combination, if one posses a license for the
IBM C/C++ compiler.

One may tell the C/C++ compiler both the minimum supported hardware and
the most typical hardware used. So the compiler uses only instructions
available on that minimum hardware and optimizes with instructions that
work best on the typical hardware.  Based on my z/OS 2.2 installation
default, I chose ARCH(8) TUNE(8) however, there should not be a problem
to go down to ARCH(7) TUNE(7) or up to current level (on my 2.3 system
the default is already TUNE(10) ARCH(10).)

The assembler parts are assembled and work fine in ZS-4.  According to
John, we may, if required, get it down to ZS-1 as there are only three
instructions that need the higher level (MVHHI, CFI and CLHHSI) and
they are relatively easy to replace.

(The C ARCH numbers are two behind the marketing numbers: a z13 is
ARCH(11). The HLASM MACHINE numbers are four behind: a z13 is ZS-9.)

One may also tell the C/C++ compiler and the binder the minimum level
of LE to target. Based on the aforementioned installation we tell the
compiler TARG(LE,current) but we can go down to something like
zOSV1R13, or whatever.

Preamble. License
-----------------
The software described herein is a direct port of the open source PCRE2
package to a new platform (i.e. z/OS) and thus is distributed under the
same BSD license with the addition of John Gateley's and my name as
contributors.  This license covers each and every file in this package,
including this document.

The original PCRE package was contributed by the various contributors
mentioned in the LICENCE document.  Please refer to the document named
LICENCE in the original package for details about the various
contributors and their corresponding copyrights.  Please refer to the
document named LICENCE in the JCLLIB to see my specific copyright.

Copyright © 1997 - 2018

THE z/OS specific modifications
-------------------------------

Contributed by:  Ze'ev Atlas.

Copyright  © 2012, 2013, 2014, 2015, 2016, 2017, 2018 Ze'ev Atlas
All rights reserved.

REXX API
--------

Contributed by: John Gateley

Copyright  © 2017, 2018 John Gateley
All rights reserved.

THE "BSD" LICENCE
-----------------
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.

    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in
      the documentation and/or other materials provided with the
      distribution.

    * Neither the name of the University of Cambridge nor the name of
      Google Inc. nor the names of their contributors may be used to
      endorse or promote products derived from this software without
      specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THEIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-----------------------------------------------------------------------

Roadmap:
1. GREP functionality is not yet fully tested (see GREP discussion for
   details.)
2. The old PCRE is now stuck in 8.39.  I will not maintain the old PCRE
   any more.

!!! ALERT - z/OS and EBCDIC annoyance factors !!!
-------------------------------------------------
There are few issues that I've coined as z/OS annoyance factors that
must not be ignored.  Here is an enumeration of the main known issues.
1. In order to avoid some of EBCDIC annoyance, my development system
   is set to IBM-1047.  However, even that did not resolve all upload
   issues.  My emulator assumes that the workstation code page is 1252
   which is Windows.  It insists on changing the Chevron to X'B0' ( ¬)
   instead of X'5F'.  I use my ADDMEM utility to alleviate the issue.
2. The Tab character (X'05') causes the C compiler to fail.  I do not
   know which character to use instead, so I replaced all Tabs with
   Spaces in the source code.  This should not affect patterns as we
   rarely deal with Tab character as is.  I believe that it is
   recognized as white space as it should, but farther testing is
   needed.
3. The character y umlaut (officially known in Unicode as 'Latin small
   letter y with diaeresis' and looks like y with two dots above it, is
   mapped to X'FF' in ASCII.  X'FF' in EBCDIC is EO (i.e. EOT End of
   Transmission).  This may and would, cause issues when uploading
   ASCII files that contain that character to the mainframe.
4. When entering pattern via the PARM in the JCL, please remember that
   any Back Slash character must be doubled.  This is a requirement of
   the C compiler as far as I can tell.  Surprisingly, this annoyance
   factor is not unique to z/OS but may be seen in the Unix/Linux
   environment as well.
   Example:
   to run pcredemo to find all digits in the input string, one must
   code:
   //STEP1 EXEC PGM=PCRE2DEM,PARM='-g \\d 123'
   and not
   //STEP1 EXEC PGM=PCRE2DEM,PARM='-g \d 123'


0. Documentation
----------------
This document attempts to explain the port of PCRE2 into z/OS,
including installation.  It does not attempt to be a full documentation
of PCRE2 as PCRE2 is fully documented.  See
http://www.pcre.org/current/doc/html/ or http://www.pcre.org/pcre2.txt
for full documentation in html or text forms.
The previous incarnation of the PCRE2 library was called PCRE.  I
ported the 8.xx series to z/OS in similar manner and that port is still
available separately.  The old PCRE is on maintenance mode and it is
recommended NOT to use it for any new development.  Therefore, and
because of my limited resources, I dropped support for the old PCRE.
Instead, please use this current incarnation, PCRE2 and its port.

1. Rationale
------------
The purpose of this port is to bring Perl-style Regular Expressions
into the classic z/OS world.  PCRE2 - Perl Compatible Regular
Expressions [http://www.pcre.org/] is a mature and quite popular open
source package that provides this functionality.
The intended use of this package would be by traditional mainframe
programmers using traditional mainframe LE languages such as COBOL
within the classic native z/OS framework and file system without the
need to use USS.
The intended audience of this port are people who are working on the
classic native z/OS with LE languages, mainly COBOL.  Those people, if
they at all, have permission to load open source, would be bound to
compile it using JCL inside the classic native z/OS environment,
potentially with Sysprog mandated (i.e. written on stone) compile
options.  They may not even have access to any C compiler.  Their
target language (usually COBOL) uses LE and does not consider it to be
a bloat.  In short, my audience is the poor souls who maintain the
legacy code and would never care for the glory of the new brave world.
Note that z/OS C provides the standard Posix compliant Regular
Expression functions that could be used as is. However, PCRE2 provides
for the more robust Perl compatibility.
The main exception to the LE languages is the usage of the TSO-REXX
scripting language.  That language creates its own environment.  John
Gateley and I have developed a standard REXX API to accommodate REXX
usage.

2. Limitations of the z/OS Port and of the current Release
----------------------------------------------------------
* The current release intends to provide the use of the core PCRE2
  functionality in native z/OS environment, using the available API in
  C.
* In addition, this version provides a COBOL API that allows calling
  the various functionalities using traditional z/OS short (and
  upper-case) names.
* The port was compiled and tested under EBCDIC code-page IBM-1047.
* We rely on the standard IBM C and not on the Gnu C (GCC).  GCC
  availability on z/OS is not clear.  And I do not have the expertise
  to even try to install it, let alone use it.  Moreover, IBM C is
  fully compatible with the intended usage.  Therefore, I have no
  intention to ever switch to any other variant of C.
* REXX is now supported via Assembler modules that were supplied by
  John Gateley.  It is limited in nature by not providing the use of
  the whole API, however it provides for persisting the environment and
  reuse of compiled patterns.
* C++ is not supported.
* Also, this port does not, and will not support the JIT of the
  original package!
* This port is strictly EBCDIC (IBM-1047), to the exclusion of ASCII,
  UTF (all of them), any IBM DBCS, and any other character set one may
  imagine!  This limitation is built in and the port will never support
  any of the aforementioned character sets.
* However the port now supports all standard EBCDIC code-pages via an
  interface to the IBM iconv() facility.  Note that while the iconv()
  facility supports ASCII, various UTF and IBM DBCS character sets,
  this port still does not support and will not support them.
* The documentation is still somewhat sparse and leave a lot to be
  desired :)
* Special warning about the Posix compliant module of PCRE2:
  IBM supplies Posix compliant functions that share the same names of
  the Posix compliant functions in PCRE2.  To prevent any conflict I
  changed the names of the PCRE2 functions.  However, C programmers are
  advised to use either the IBM native Posix functions or the PCRE2
  equivalents and never mix them in the same program.  Specifically, if
  you intend to use the PCRE2 functions then do not issue
  #include <regex.h>.
  See what's new in 10.33 for changes on that matter.
* The provided LE API (PCOBAPI2.C module) would normally compile
  without support to the native IBM supplied POSIX and any call to the
  PCRE2 specific POSIX routine names will refer to PCRE2.  Support for
  compiling PCOBAPI2.C with the directive
  #define  NATIVE_ZOS_POSIX
  has been dropped since PCRE2 10.22.  (It was supposed to mask the
  PCRE2 names and cause the program to use the native POSIX routines:
  regcomp, regexec, regerror and regfree.)
* All API functions are now supported including some that were
  mistakenly missing in previous release.

3. Porting Process
------------------
The porting is done by Perl scripts that automatically handle most
issues:
1. Source module names changed in controlled manner to reflect z/OS' 8
   character member name limitation.  (some names were later tweaked
   manually)
2. All #include changed to refer to the above transformed names.
3. All references to external module source names are resolved by using
   automatically created #pragma directive statements (i.e. internal
   calls for long names functions have NOT been changed.)
4. Internal long function names were automatically resolved in linkage
   time without the need for such #pragma directives.
5. For all internal function names, there are also traditional z/OS
   aliases (8 character upper case) provided via dedicated COBOL API
   module.
6. All fopen are changed to avoid binary files (i.e. "r" or "w" instead
   of "wb" or "rb".
7. The character y umlaut (officially known in Unicode as 'Latin small
   letter y with diaeresis' and looks like y with two dots above it is
   changed to \xFF to prevent z/OS' FTP failure.  [The character is
   ASCII \xFF and is understood by the mainframe's file load as sort of
   EOT or EOF.  I am not sure about the official reason, but the bottom
   line is that the transmission is cut.  This document is basically an
   ASCII document, but since it is uploaded to the mainframe into the
   JCLLIB, I refrained from putting the actual character in this
   document.]
8. all \t changed to 4 spaces as the mainframe C compiler does not like
   tabs in the source code.
9. Some code is added to enforce usage of config.h.  The supplied z/OS
   compatible config.h was manually adjusted.  One important definition
   in that config.h is the line
   #define NATIVE_ZOS 1
   which is used to recognize the z/OS environment.  However, there are
   other required #define statements which are introduced via compile
   time option file.  The difference is that those #define are not z/OS
   specific and could be used in other contexts as well.
10. All C #include files are (at least for now) considered local.
   Therefore #include <pcre2.h> is changed to #include "PCRE2.H".
11. In addition to the core PCRE2 modules, this package provides a few
   additional modules:
11.1. pcrzfunc.c provides some text manipulation functions to deal with
   null terminated and non-null terminated strings in the mixed C/COBOL
   environment.  While the Enterprise COBOL supports PIC Z character
   strings which are essentially null terminated strings, most
   traditional COBOL programs use the old, fixed length PIC X strings.
   The functions herein come to help you manipulate such strings.
   In addition, this module contains the functions that allow PCRE2 to
   manipulate the various EBCDIC code-pages transparently in behind-
   teh-scene manner.
11.2. pcrzconh.h is used to provide structures for the iconv()
   interface.
11.3. pcobapi2.c provides the COBOL/LE API.
11.4. pcrzosfs.h is used internally by the pcre2grep utility to handle
   PDS files as if they were directories.
11.5. pcrzoscs.h is used internally by the pcre2test utility to
   approximate the EBCDIC code page.
11.6. echo.c is an implementation of the Unix echo.
11.7. ibmsampl.c explained elsewhere to demonstrate Posix usage.
11.8. pc2psxap.h is used to provide C structures for Posix usage.
11.9. pcrprgma.h provide pragma statements to map long C names to short
   PDS memeber names.
13. The package includes a port of the demo program pcre2demo.c into
   COBOL as PCOBDEM2 and a library of necessary copybooks, some are
   ports of the native PCRE2 header files and some are new copybooks
   providing well defined structures to handle various aspects of the
   API in more bearable way then what is provided by C.
14. I am working on availability of this package in Github. As part of
  this availability, I intend to provide the Perl scripts and the
  manual scripts on how to run them.

4. Available Files
------------------
1. ADDJCL.JCL   - JCL to load the JCL, ADDMEM
2. ADDMEM.REX   - a REXX utility to load VB members to VB source
   library
3. zos.jcl.txt  - the supplied installation JCL
4. zos.load.txt - the supplied source code
5. zos.lked.txt - the supplied Binder parameters and REXX modules.
6. zos.test.txt - the supplied test suite
7. zos.cob.txt  - the supplied COBOL components
8. zos.asm.txt  - assembler modules for REXX support
9. C14_MACRO.ieb - assembler macro needed for #8
10. pcre2doc.txt - this file
11. readme.txt - the readme file that accompanied the GIT HUB version.
Note that the LICENCE file, the readme file and the pcre2doc file are
available as part of the JCLLIB.
12. XMI files representing the various z/OS side installed libraries
   corresponding to the files above.  The XMI libraries are in EBCDIC,
   IBM-1047, and should be uploaded in binary mode.
* PCRE2.CNTLLIB.XMI
* PCRE2.COB.XMI
* PCRE2.JCLLIB.XMI
* PCRE2.LOADLIB.XMI
* PCRE2.SRCE.XMI
* PCRE2.TESTLIB.XMI
* PCRE2.ASM.XMI
* PCRE2.C14.MACLIB.XMI - strictly speaking this is not a part of the
  port, but a set of macros from John Gateley that are available
  elsewhere.  It is supplied here because it is necessary for compiling
  the assembler for REXX support.
13. LICENCE.ebc  - License file in EBCDIC.
14. PCRE2DOC.ebc - This document in EBCDIC.
15. readme.ebc - readme file in EBCDIC.
Note that the distribution on the CBTTAPE site (www.cbttape.org)
contains only the files mentioned in #11 through #13 as it is EBCDIC
only distribution.

5. installation:
----------------
0. You may use the supplied XMIT libraries and save the installation
   process if you are on IBM-1047 code-page.
1. create libraries:
Use your own high level qualifier instead of HLQ
HLQ.PCRE2.CNTLLIB - regular source library - LRECL=80,RECFM=FB; caps
   off
HLQ.PCRE2.JCLLIB  - regular source library - LRECL=80,RECFM=FB; caps
   off
HLQ.PCRE2.LOADLIB - load module library, must be a PDSE -
   BLKSIZE=27998,RECFM=U
HLQ.PCRE2.SRCE    - source library - but LRECL=255,RECFM=VB; caps off
HLQ.PCRE2.TESTLIB - source library - but LRECL=4096,RECFM=VB; caps
   off
HLQ.PCRE2.COB     - PDSE library - LRECL=80,RECFM=FB; caps off
HLQ.PCRE2.ASM     - regular source library - LRECL=80,RECFM=FB; caps
   off
HLQ.C14.MACLIB    - regular source library - LRECL=80,RECFM=FB; caps
   off

Optional HLQ.PCRE2.SYSOUT  - a library to store test results -
                  - LRECL=133,RECFM=FBA
Optional HLQ.PCRE2.STDOUT  - a library to store test results -
                  - LRECL=31000,RECFM=VB

Here is the relevant allocation sizes information on my system
                                                   Tracks %Used
---------------------------------------------------------------
ZATLAS1.C14.MACLIB                                     15   73
ZATLAS1.PCRE2.ASM                                      10  100
ZATLAS1.PCRE2.CNTLLIB                                   3  100
ZATLAS1.PCRE2.COB                                       8   55
ZATLAS1.PCRE2.JCLLIB                                   16   93
ZATLAS1.PCRE2.LOADLIB                                 127   93
ZATLAS1.PCRE2.SRCE                                     70   78
ZATLAS1.PCRE2.SYSOUT                                  495   59
ZATLAS1.PCRE2.TESTLIB                                 161  100
------
The member ALLOCPDS in the HLQ.PCRE2.JCLLIB is a sample of how to
create those libraries in batch, but using ISPF 3.2 works as well.
2. Load all files starting with zos, ADDJCL.JCL and addmem.rex to the
   mainframe.  My convention, reflected in the JCL, is to drop the txt
   suffix, so, for example, zos.jcl.txt will become HLQ.ZOS.JCL.
   Important:
   addmem.rex, addjcl.jcl, zos.jcl.txt, zos.cob.txt, and zos.lked.txt
   should be uploaded with attributes LRECL 80, FB;
   zos.load.txt should to be uploaded with attributes LRECL 255, VB;
   zos.test.txt should be uploaded with attributes LRECL 4014, VB;
3. Use the ADDJCL.JCL IEBUPDTE job in this package to load the
   HLQ.ZOS.JCL to the HLQ.PCRE2.JCLLIB and the HLQ.ADDMEM.REX to the
   HLQ.PCRE2.CNTLLIB.
4. Adjust the various JCL to point to the above libraries.  The JCL
   members contain // SET statements after the JOB statement.  Locate
   those that deal with the high level qualifiers and change them to
   your own.
5. Run HLQ.PCRE2.JCLLIB(ADDMEM) to load zos.load into HLQ.PCRE2.SRCE.
   Loading zos.load is pretty slow process.  (see below a note for the
   usage of ADDMEM.)
6. Run HLQ.PCRE2.JCLLIB(ADDCNTL) to load zos.lked into
   HLQ.PCRE2.CNTLLIB.
7. Run HLQ.PCRE.JCLLIB(ADDTEST) to load zos.test into
   HLQ.PCRE2.TESTLIB.
8. Run HLQ.PCRE.JCLLIB(ADDCOB) to load zos.cob into HLQ.PCRE2.COB.
9. Run HLQ.PCRE.JCLLIB(COMPCRE2) to compile and link the whole package.
10. Run HLQ.PCRE.JCLLIB(ZCOBCL) to compile and link the PCOBDEMO, COBOL
   demo program.
11. You may now modify and run HLQ.PCRE2.JCLLIB(TESTPCRE) to see test
   results.  Some of the run options are irrelevant for z/OS.
   Similarly, you may run HLQ.PCRE.JCLLIB(TESTPCOB) and
   HLQ.PCRE.JCLLIB(TESTDEMO), to see demo results in both COBOL and C.
12. Run HLQ.PCRE2.JCLLIB(ADDASM) to load zos.asm into HLQ.PCRE2.ASM and
   C14_MACRO.ieb to HLQ.C14.MACLIB.
13. Run HLQ.PCRE2.JCLLIB(REXXPCRE) to compile the REXXPCRE module,
   which is the REXX API.

Note for loading ASCII text to EBCDIC environment, FTP parameters and
the usage of the ADDMEM utility with the TRANSLAT option:
-----------------------------------------------------------------------
The ADDMEM utility mimics simple IEBUPDTE ./ ADD operation for FB/VB
and whatever LRECL input/output on a z/OS/TSO environment.  This
utility is very limited in nature and there was no attempt to optimize
its operation.  The utility supports only the ./ ADD NAME=member
operation of IEBUPDTE.  It assumes that the output library is
pre-allocated and is the same format as the input file.  It intends to
support only RECFM=F|FB|V|VB.
There are two reasons for this utility.  The fact that IEBUPDTE appears
not to support anything that is not RECFM=FB,LRECL=80 while this
package core programs are in RECFM=VB,LRECL=255, and the ASCII to
EBCDIC transformations.  There are other solutions for the first
problem including free programs on cbttape (file 182), however I did
not want to rely on any external package and I needed the TRANSLAT
option.
Loading ASCII text into an EBCDIC environment could be challenging.  In
many cases you do not have any control on the code-page, no use of FTP
or other issues.  I for example, had to use the venerable IND$FILE with
whatever defaults set by the System Programmer to whom I had no access.
If you have access to FTP, you could try using something like:
Sbdataconn=(ibm-1047,iso8859-1)
which is the preferable setting and should be the go to setting, or
Sbdataconn=(ibm-037,iso8859-1)
where the ibm-xxxx denotes your specific IBM code-page.  However this
may not resolve all the issues.
The main issue I'd encountered was the fact that the C compiler on z/OS
assumes IBM-1047 while many installations use IBM-037.  Thus the
compiler appears to be using logical not instead of circumflex.  If you
must use something different than IBM-1047 for uploading you may
resolve it by adding the TRANSLAT option to the ADDMEM utility.  It is
used by changing the TRANSLAT DD from DUMMY to '*' and adding input
instructions like:
'B0'X '5F'X
'05'X '40'X
/*
These are instructions for ADDMEM to translate any, let's say x'B0' to
x'5F', etc.  In particular these may be needed in order to change all
occurrences of the "circumflex" sign '^' (x'B0') with the IBM version
"logical not" sign ' ¬' (x'5F') which is what the IBM C compiler wants,
and the tab character (x'05') which the C compiler does not like, with
space (x'40').  IBM C compiler defaults to IBM-1047 and that is what
my environment is set to, so I do not need these transformations.
However, one could set addmem to ignore the aforementioned translation
for source lines that are tagged with '<TAG> somewhere in the line.

6. Usage
--------
This port is based on the PCRE2 library (see the beginning of the
document to determine exactly which version.)  A version of COBOL API
is provided.  Please refer to the table below for a list of available,
specifically unavailable and maybe available functionalities.
1. Jit specific functions, were not and will not be available and not
  even mentioned.
2. The functions may be available by their long, case sensitive name.
  These functions are available in C, providing that the 'Located in'
  module is bound.  These functions have the same signatures as
  described in PCRE2 documentation.  These names are also available in
  COBOL, providing that the using program is compiled with
  PGMNAME(LONGMIXED) compile option.
2. In PCRE2 there is a short, upper case name alias for all functions.
  That name is available via the COBOL API module PCOBAPI2.  Those new
  names are mentioned immediately following the word 'same', with same
  signatures as described in PCRE2 documentation.
3. VERY IMPORTANT - JIT functions are unavailable.  They might be
  available in the code but calling them would produce unpredictable
  results.  See below a discussion about JIT unavailability.  Thus,
  there might be source code members which are not compiled in the
  installation JCL.  Please do not attempt to compile or run any of
  those pieces.
4. Very important - Only tstin1, tstin2, tstin15, testin16, testin18,
  testin20 and tstin21 members in the original test suite are currently
  of any relevance.  This list may change! Be aware that all available
  test suites are ASCII oriented and your results will differ from the
  published PCRE2 results.
4. I added some specialized EBCDIC oriented tests and their results
  (see discussion about the test suite.)
6. The PCRE2 documentation discusses various forms of 'newline'
  processing.  For COBOL, all this is irrelevant as there is no such
  concept in COBOL.  In C a 'newline' (x'15') character is added and in
  text files (at least from the SYSIN [standard input]) the trailing
  spaces are chopped.  This is done internally by the C i/o and is not
  controlled by PCRE2.
7. JCL PARM= in C context adheres with C semantics, so in PCR2DEMO, if
  the pattern (or the subject) contains a backslash (\) it will be
  considered as an escape character.  If one actually wants a
  backslash, then double it (\\).  COBOL does not have this problem.
8. Make sure that the library HLQ.PCRE2.LOADLIB appears in the correct
  concatenation order in your runtime '//STEPLIB DD' statement and in
  bind (linkedit) time in the '//SYSLMOD DD' statement.
  Make sure that the HLQ.PCRE2.SRCE library appears in your
  //USERLIB DD or ahead of all other C libraries in //SYSLIB when
  compiling in C.
  Make sure that HLQ.PCRE2.COB appears in //SYSLIB DD when compiling in
  COBOL.
  Please add INCLUDE SYSLIB(PCOBAPI2) to the binder to use the short
  names.
  Please add INCLUDE SYSLIB(PCRZFUNC) to the binder to use the pcrz
  functions if you are not including the PCOBAPI2 above.

Function                                New name    Located in
--------                                --------    ----------
pcre2_code_copy                         CODECOPY    COMPILE2
pcre2_code_copy_with_tables             CODECOPT    COMPILE2
pcre2_code_free                         CODEFREE    COMPILE2
pcre2_compile                           COMPILE2    COMPILE2
pcre2_match                             MATCH2      MATCH2
pcre2_dfa_match                         DFAMATC2    DFAMATC2
pcre2_match_data_create                 MATCHDCR    MATCHDA2
pcre2_match_data_create_from_pattern    MATCDCFP    MATCHDA2
pcre2_match_data_free                   MATCHDFR    MATCHDA2
pcre2_get_match_data_size               GETMTCSZ    MATCHDA2
pcre2_get_mark                          GETMARK     MATCHDA2
pcre2_get_ovector_count                 GETOVECN    MATCHDA2
pcre2_get_ovector_pointer               GETOVEPT    MATCHDA2
pcre2_get_startchar                     GETSTART    MATCHDA2
pcre2_general_context_create            GENCNTCR    CONTEXT2
pcre2_general_context_copy              GENCNTCP    CONTEXT2
pcre2_general_context_free              GENCNTFR    CONTEXT2
pcre2_compile_context_create            CMPCNTCR    CONTEXT2
pcre2_compile_context_copy              CMPCNTCP    CONTEXT2
pcre2_compile_context_free              CMPCNTFR    CONTEXT2
pcre2_convert_context_copy              CNVCTXCP    CONTEXT2
pcre2_convert_context_create            CNVCTXCR    CONTEXT2
pcre2_convert_context_free              CNVCTXFR    CONTEXT2
pcre2_set_bsr                           SETBSR      CONTEXT2
pcre2_set_character_tables              SETCHRTB    CONTEXT2
pcre2_set_newline                       SETNEWLN    CONTEXT2
pcre2_set_parens_nest_limit             SETPRNLM    CONTEXT2
pcre2_set_compile_extra_options         SETCEXOP    CONTEXT2
pcre2_set_compile_recursion_guard       SETCMRCG    CONTEXT2
pcre2_set_depth_limit                   SETDEPLM    CONTEXT2
pcre2_set_glob_escape                   SETGLBES    CONTEXT2
pcre2_set_glob_separator                SETGLBSP    CONTEXT2
pcre2_set_heap_limit                    SETHEPLM    CONTEXT2
pcre2_match_context_create              MTCCNTCR    CONTEXT2
pcre2_match_context_copy                MTCCNTCP    CONTEXT2
pcre2_match_context_free                MTCCNTFR    CONTEXT2
pcre2_set_callout                       SETCALOT    CONTEXT2
pcre2_set_match_limit                   SETMTCLM    CONTEXT2
pcre2_set_recursion_limit               SETRCNLM    CONTEXT2
pcre2_set_offset_limit                  SETOFFLM    CONTEXT2
pcre2_set_max_pattern_length            SETMXPLN    CONTEXT2
pcre2_set_recursion_memory_management   SETRCNMM    CONTEXT2
pcre2_converted_pattern_free            CNVPATFR    CONVERT2
pcre2_pattern_convert                   PATTCONV    CONVERT2
pcre2_substring_copy_byname             SUBCPNAM    SUBSTRI2
pcre2_substring_copy_bynumber           SUBCPNUM    SUBSTRI2
pcre2_substring_free                    SUBSTFR     SUBSTRI2
pcre2_substring_get_byname              SUBGTNAM    SUBSTRI2
pcre2_substring_get_bynumber            SUBGTNUM    SUBSTRI2
pcre2_substring_length_byname           SUBLNNAM    SUBSTRI2
pcre2_substring_length_bynumber         SUBLNNUM    SUBSTRI2
pcre2_substring_nametable_scan          SUBNMSCN    SUBSTRI2
pcre2_substring_number_from_name        SUBNMFNM    SUBSTRI2
pcre2_substring_list_free               SUBLSTFR    SUBSTRI2
pcre2_substring_list_get                SUBLSTGT    SUBSTRI2
pcre2_substitute                        SUBSTIT2    SUBSTIT2
pcre2_jit_compile                       JITCOMP2    JITCOMP2
pcre2_jit_match                         JITMATC2    JITMATC2
pcre2_serialize_decode                  SERIADCD    SERIALI2
pcre2_serialize_encode                  SERIAENC    SERIALI2
pcre2_serialize_free                    SERIAFR     SERIALI2
pcre2_serialize_get_number_of_codes     SERGTNMC    SERIALI2
pcre2_get_error_message                 GETERROR    ERROR2
pcre2_maketables                        MAKETAB2    MAKETAB2
pcre2_maketables_free                   MAKETABF    MAKETAB2
pcre2_pattern_info                      PATTERN2    PATTERN2
pcre2_callout_enumerate                 CALOTENM    PATTERN2
pcre2_config                            CONFIG2     CONFIG2
pcre2_script_run                        SCRIPTR2    SCRIPTR2
free(***)                               FREEMAIN
malloc(***)                             GETMAIN
pcrz_what_term_str(*)                   ZWHTTRM     pcrzfunc
pcrz_is_space_term_str(*)               ZISSPTRM    pcrzfunc
pcrz_is_null_term_str(*)                ZISNLTRM    pcrzfunc
pcrz_space_to_null_term_str(*)          ZSPC2NUL    pcrzfunc
pcrz_null_to_space_term_str(*)          ZNUL2SPC    pcrzfunc
pcrz_codeset_init(****)                 ZCSINIT     pcrzfunc
pcrz_codeset_convert_pattern(****)      ZCSCONVP    pcrzfunc
pcrz_codeset_convert_subject(****)      ZCSCONVS    pcrzfunc
pcrz_codeset_init_substitute(****)      ZCSINIS     pcrzfunc
pcrz_codeset_convert_replacement(****)  ZCSCONVR    pcrzfunc
pcrz_codeset_convert_substitute_back    ZCSCONVB    pcrzfunc
pcrz_codeset_release(****)              ZCSRLSE     pcrzfunc
regcomp(**)                             PREGCOMP    PC2POSIX
regexec(**)                             PREGEXEC    PC2POSIX
regerror(**)                            PREGERR     PC2POSIX
regfree(**)                             PREGFREE    PC2POSIX

(*) indicates supporting functionality, not available in the original
  PCRE2 package and was added to support the COBOL environment.
{**) Posix - the old name could be used.  See comments about the API
  elsewhere in this document.  Use of these alternative names is
  deprecated.  Instead, use the native POSIX names in conjunction with
  PC2PSXAP.h header and provide DEF(COMPILE_WITH_PCRE2) compile option.
(***) indicates that the new name is not implemented as a port, but as
  a new functionality, available in PCOBAPI2 only
(****) codeset manipulation functions used to convert internally EBCDIC
  strings (patterns and subject strings) of all code-pages to IBM-1047.
  See EBCDIC Horror bellow.

7. Calling the PCRE2 functions from COBOL
-----------------------------------------
I urge anyone who wants to interface between COBOL and C to read the
excellent Share paper "What is ILC and how to use it-COBOL, PL/I and
C/C++" by Mr. Tom Ross, Share Session 8239, August, 2003. The paper
could be found here:
http://www-01.ibm.com/support/docview.wss?uid=swg27003846&aid=1
I opted to use the pragma-less option and call the C modules in the
most native way because the C modules potentially, need to interact
with other C modules and not only with COBOL.
I assume that practically everybody working in z/OS nowadays uses
Enterprise COBOL version 3 and up and up and almost nobody would try to
retrofit older programs to use PCRE.  Thus, the assumption is that the
user may call any module using BY VALUE, BY REFERENCE and RETURNING
clauses in COBOL.  If there would be enough popular demand I may opt to
write a special COBOL API module that could be used without the
RETURNING clause.
The most important point is that when C function parameter list
requires a pointer (char * variable), the preferred way to mention that
parameter would be to use a pointer rather then allow the parameter
list to implicitly provide that pointer.  Theoretically, one could use:
CALL 'function' USING BY REFERENCE VARIABLE
instead of:
CALL 'function' USING BY VALUE SOMEPOINTER
where the pointer SOMEPOINTER points to VARIABLE, but if that variable
is the last in the parameter list, then, by z/OS calling sequence
convention the highest bit is on in the last reference of the parameter
list and this would cause issues with C's pointer arithmetic.
Please refer to the PCOBDEM2 program, port of the pcr2demo.c for
examples of such calls.  The example herein is taken from that program
    call 'COMPILE2' using
         by value     pcrews-pattern-ptr
         BY VALUE     PCRE2-ZERO-TERMINATED
         BY VALUE 0
         BY reference PCREWS-errornumber
         BY reference pcrews-erroroffset
         BY VALUE pcrews-null-ptr
         RETURNING PCREWS-RE-PTR
    end-call
The C definition of this module is:
    pcre2_code *pcre2_compile(PCRE2_SPTR pattern, PCRE2_SIZE length,
         uint32_t options, int *errorcode, PCRE2_SIZE *erroroffset,
         pcre2_compile_context *ccontext);
* The C module pcre_compile has become COMPILE2.
* The returned value of type pointer to type pcre2_code is mentioned in
  the RETURNING clause.  PCREWS-RE-PTR is defined in COBOL as USAGE
  POINTER.
* The first parameter is of type pointer to a character string and is
  pointed to by pcrews-pattern-ptr, also defined as USAGE POINTER and
  is pointing to pcrews-pattern, a character string.
* The next parameter is a constant of type integer is passed by value.
* The next parameter of type integer is passed by value (0).
* The next two parameters, pointers to integers demonstrate the ability
  to use BY REFERENCE and avoid a pointer.
* The last parameter, a pointer to a character string is a passed by
  value as discussed above.  In that case, that pointer points nowhere
  (contains NULL value.

8. COBOL copybooks
-----------------------------
Some of the publicly available C #include modules were ported, broken
and adapted to COBOL.  See the PCOBDEM2 programs for demonstration on
how to use some of them:
PCRCMPCN - implementation of pcre2-compile-context.
PCRECAL2 - implementation of pcre2-callout-block and
   pcre2-callout-enumerate-block.
PCRECODE - implementation of pcre2-code.
PCREWS2  - useful working-storage section variables to be used by most
   COBOL programs.
PCRE2    - a port of the public header (pcre2.h).
PCRGENCN - implementation of pcre2-general-context.
PCRECTXT - implementation of pcre2_convert_context
PCRMECTL - implementation of pcre2-memctl.
PCRMTCCN - implementation of pcre2-match-context.
PCRMTCDA - implementation of pcre2-match-data.
DUMPMEM  - a function, implemented as sub program, to dump memory for
   test purposes.

8. EBCDIC Horror
----------------
As many of you know, EBCDIC is NOT one code page but actually several
distinct code pages.  The most common difference between one version
of EBCDIC to another is language specific where Greek, Turkish, Hebrew,
Cyrillic, Arabic, etc. characters have to be supported in EBCDIC for
the various locales that use IBM mainframes.  Famous examples are:
IBM-037 - USA/Canada - CECP
IBM-273 - Germany F.R./Austria - CECP
IBM-276 - Canada (French) - 94
IBM-277 - Denmark, Norway - CECP
IBM-297 - France - CECP
IBM-284 - Spain/Latin America - CECP
IBM-285 - United Kingdom - CECP
IBM-423 - Greece - 183
IBM-424 - Israel (Hebrew)
IBM-425 - Arabic/Latin for OS/390 Open Edition
IBM-1025 - Cyrillic, Multilingual
IBM-1026 - Latin #5 - Turkey
IBM-1047 - Latin 1/Open Systems
(see https://www-01.ibm.com/software/globalization/cp/cp_cpgid.html
for an extensive list, including non-EBCDIC and multi-byte codes.
Note that the discussion inhere assumes only eight bits code sets!)
The fact of multi-EBCDIC code pages unto itself should not be a problem
for any regular expression engine (or any other software).  The real
problem is IBM's (mis)handling of some special characters! Specifically
the characters $,^,[,],# (and others) may occupay totally different
code points between one code page to the other.  And these are some of
the most prominent special characters that are used to express regular
expressions.
I admit not being fully aware about the situation and not fully
handling it in the versions of PCRE/PCRE2 for z/OS prior to the current
version.  So much so that I will have to rewrite parts of the
documentation and slightly change my automated process.  However, I
would like to push this version, with the proper remedy for the issue,
out of the door immediately and than go back and redo the process and
the documentation.

8.1. Solution for PCRE2
-----------------------
In devising a solution for the EBCDIC Horror I had these design goals
in mind:
1. Users of PCRE2 are interested in applying regular expressions to
   their subject strings and not in performing cumbersome code-page
   conversions.
2. The most reliable way to handle code page differences must be a
   tried and true method, preferably from the vendor (IBM) and not
   some new development.
3. For most users, but not all, the native (locale) code-page is also
   the code page that they see on their emulator.  Those users should
   not be bothered with the code page specifics.
In essence I wanted to provide a minimal API that would hide as much of
the gory details from the user.
IBM has settled on IBM-1047 as the best option and is using it as the
base code page.  The IBM C compiler is specifically geared to work in
IBM-1047 as its native code page.  Thus, if you work with IBM-1047 and
only with IBM-1047, you may use the PCRE2 in this distribution as is
and not bother with the rest of this document.
IBM also supply a set of standard conversion function that are
available to all in their C/C++ Runtime Library.  These are the
iconv(), iconv_open() and iconv_close() functions which when are
coupled with the setlocale() and nl_langinfo() functions and with the
langinfo.h, locale.h and iconv.h header files could help to correctly
convert any EBCDIC string between any pairs of EBCDIC (and to some
extent, non-EBCDIC) code pages.
The new version of PCRE2 for z/OS provides a front end for using this
conversion functionality in tandem with PCRE2 while hiding the gory
details from the user who is interested in using regular expressions,
not in string conversions, memory allocations, etc.  In essence, the
user calls these API functions and pass the results to PCRE2.  BUT the
user should NEVER look directly at the results of of these functions.
Rather, the user should stick with his/her own original regular
expressions and subject strings in their original code page.
Here is the API, described in C.  Whenever the parameter to the
function is described with **, it is the same as 'by reference' and
provides a value returned to the user.
The basic usage of this API is a one time initialization of the
conversion process and then convert the input regular expression and
input subject string.  The converted strings are then to be supplied
to the PCRE2 in the usual way.
The output 'ovector' is a vector of offsets.  These are valid offsets
against the original unconverted input, so there is no need to
convert back.  The user has to just use the original subject with the
'ovector'.  The names of named captured patterns in the ovector are
limited to [A-Za-z0-9_].  As far as I know, these are not really a
subject for the EBCDIC horror, so there should be no conversion back
on those as well.

/*  pcrz_codeset_init <=> ZCSINIT  */
int pcrz_codeset_init (ZCSSTRCT ** handle_ptr,  /* returned handle */
   char * codeset_name,  /* input codeset name e.g. IBM-037
       or NULL if locale codeset is to be used */
   size_t codeset_name_size, /* codeset name size - actual size or:
                            -1 for null terminated
                            -2 for space terminated */
   size_t pattern_size,  /* maximum anticipated regex size or 0 for
                            default */
   size_t subject_size); /* maximum anticipated subject string size
       or 0 for default */

1. Determines the native (or use supplied) input CODESET.  If a codeset
   name is not supplied (NULL), the function will use the locale
   information.
2. Initialize conversion from that codeset into IBM-1047.
3. Allocate two blocks of memory for the IBM-1047 intermediate
   strings, one for the pattern and one for the subject string.
Warning: you may run on a machine with one native codest while you
view it as another (a common scenario would be running on a standard
IBM-1047 installation while your 3270 emulator is set to, let's say,
IBM-285 because you are in the UK.)  In such cases you have to override
the locale by supplying your emulator codeset.
Note that the internal CODESET is always IBM1-1047 which is the IBM
C/C++ compiler default and the way the binaries are distributed.
pattern_size and subject_size are the estimated maximum sizes for
the largest pattern and largest subject string, default to 2048 and
8192 correspondingly when the user specifies 0 value.
The returned handle should be preserved.
The function returns -1 in case of failure, 0 in case of success and 1
when no conversion is necessary.  The user should not bother with the
distinction between rc 0 and 1 as the other sunctions know how to
handle both situations.

/*  pcrz_codeset_init_substitute <=> ZCSINIS         */
int pcrz_codeset_init_substitute (ZCSSTRCT * handle_ptr, /* handle
                      returned from ZCSINIT */
    size_t replacement_size, /* maximum anticipated replacement string
                      size or 0 for default */
    size_t substitute_size); /* maximum anticipated substituted result
                      stringsize or 0 for default */

When using the substitute functionality we need to supply two more
components, the replacement string/pattern and the budder for the
result substituded string.

/*  pcrz_codeset_convert_pattern <=> ZCSCONVP */
int pcrz_codeset_convert_pattern (ZCSSTRCT *zcsstrct_ptr, /* handle
                      returned from ZCSINIT */
    char * input_pattern,  /* pointer to input regex */
    size_t pattern_length, /* regex size or 0 for null
                      terminated string */
    char ** output_pattern, /* handle for converted regex to be
                      supplied to PCRE2 compile function */
    size_t ** out_pattern_length);    /* converted regex size */
/*  pcrz_codeset_convert_subject <=> ZCSCONVS */
int pcrz_codeset_convert_subject (ZCSSTRCT *zcsstrct_ptr, /* handle
                      returned from ZCSINIT */
    char * input_subject,  /* pointer to input subject string */
    size_t subject_length, /* subject string size or 0 for null
                      terminated string */
    char ** output_subject, /* handle for converted subject string
                      to be supplied to PCRE2 execute function */
    size_t ** out_subject_length); /* converted subject string
                      size */
/*  pcrz_codeset_convert_replacement <=> ZCSCONVR */
int pcrz_codeset_convert_replacement (ZCSSTRCT *zcsstrct_ptr,
                      /* handle returned from ZCSINIT */
    char * input_replacement,  /* pointer to input replacement
                      string */
    size_t replacement_length, /* replacement string size or 0
                      for null terminated string */
    char ** output_replacement, /* handle for converted replacement
                      string to be supplied to PCRE2 sunbstitute
                      function */
    size_t ** out_replacement_length); /* converted subject string
                      size */
/*  pcrz_codeset_convert_substitute_back <=> ZCSCONVB */
int pcrz_codeset_convert_substitute_back (ZCSSTRCT *zcsstrct_ptr,
                      /* handle returned from ZCSINIT */
    char * input_substitute,  /* pointer to input substitute
                      string - this one has to be converted back to
                      the original coceset*/
    size_t substitute_length, /* substituted string size or 0
                      for null terminated string */
    char ** output_substitute, /* handle for converted back
                      substituded string for the user */
    size_t ** out_substitute_length); /* converted substitute string
                      size */

These are front end conversion functions, converting pattern, subject
strings or replacement string (for substitution) from the local codeset
to IBM-1047.  This is done via three distinct functions to avoid user
direct interaction with the gory details:
The functions return pointer to converted string and its size.  If size
is not supplied (value 0) the function will assume a zero terminated
input string and will calculate the length.
The functions returns -1 in case of failure and 0 in case of success

Note that the last function is slightly different.  Its result is not
for internal use as this returns to the user the actual converted back
(to user's codest) result string.

/*  pcrz_codeset_release <=> ZCSRLSE          */
extern void pcrz_codeset_release (ZCSSTRCT *zcsstrct_ptr);
                            /* handle returned from ZCSINIT */

Releasing the formerly initialized environment and deallocating any
allocated memory.

8.2 Usage (brief description)
-----------------------------
ZCSINIT - To be called first.  it returns a handle for a structure to
manage all allocated memory.  This handle is used by all other
functions.  Note that every pattern requires its own ZCSINIT and
handle.  Provide codeset name, max pattern (or zero for default size)
and max subject size (or zero.)

Now, unless the native codest is IBM-1047, call ZCSCONVP to convert
the pattern and ZCSCONVS to convert the subject to IBM-1047.  Provide
the handle from ZCSINIT and other parameters (see above.)

For match, this is it, no more initialization is required.

For substitution, one should call the ZCSINIS using the handle from
ZCSINIT, max size of the replacement (or zero for defaults size) and
max size of the substitute output (or zero.)

Now call the ZCSCONVR to convert the replacement string. Same
parameters as all other conversion functions

After calling the substitute function, call the ZCSCONVB, where the
input is the output of the substitute (in IBM-1047) and the output will
be a pointer to the converted back string (or same string if no
conversion is needed.)

Once done, call ZCSRLSE to get release all allocated memory.
Note about ZCSRLSE:  This function releases all blocks of memory that
were acquired by ZCSINIT and ZCSINIS for a specific pattern/subject
pait.  The user is still responsible for releasing memory acquired by
the core library functions.  Use the below functions as appropriate:
    pcre2_code_free                CODEFREE
    pcre2_match_data_free          MATCHDFR
    pcre2_general_context_free     GENCNTFR
    pcre2_compile_context_free     CMPCNTFR
    pcre2_convert_context_free     CNVCTXFR
    pcre2_match_context_free       MTCCNTFR
    pcre2_converted_pattern_free   CNVPATFR
    pcre2_substring_free           SUBSTFR
    pcre2_substring_list_free      SUBLSTFR
    pcre2_serialize_free           SERIAFR
    pcre2_maketables_free          MAKETABF
    regfree                        PREGFREE

Return codes
-1 is a failure, 0 is success
ZCSRLSE does not return any value

Default sizes
#define PCRZ_MAX_PATTERN_SIZE 2048
#define PCRZ_MAX_SUBJECT_SIZE 8192
#define PCRZ_MAX_REPLACEMENT_SIZE 1024
#define PCRZ_MAX_SUBSTITUTE_SIZE 16384
#define PCRZ_MAX_CODESET_SIZE 16
MAX_NUM_COMPILES     EQU   12   max simultaneous compiles
______________________________________________________________________
List of available error messages:

ZCSINIT-001: failed to allocate ZCSSTRCT block
ZCSINIT-002: CODESET name length %d too large
ZCSINIT-003: CODESET name too long
ZCSINIT-004: CODESET name size %d too large
ZCSINIT-005: Cannot open converter from %s to %s
ZCSINIT-006: failed to allocate space for converted pattern
ZCSINIT-007: failed to allocate space for converted subject
ZCSINIT-008: Cannot open converter from %s to %s
ZCSINIT-010: failed to allocate space for converted replacement
ZCSINIT-011: failed to allocate space for converted substitute
ZCSINIT-012: failed to allocate space for converted substitute back
ZCSCONVx-001: target length gt allocated block
ZCSCONVx-002: Error in converting subject string
ZCSCONVx-003: Unknown supplied function %s

9. REXX API
-----------
Notice that the this section is John Gateley's documentation which I
had modified only slightly.
______________________________________________________________________

 RXPCRE2 - interface between the Rexx language on z/OS and the
 PCRE2 - regex processing library on same platform.
 REXPCRE - same interface for non-representative calls.

 Version 0.3
 Contributed by:   John Gateley  November 2017.
 Copyright (c) 2017, John Gateley.
 All rights reserved.
______________________________________________________________________

 This interface was written by John Gateley in September 2017 and is
 designed to be used with the  z/OS port of 'PCRE2 - Perl Compatible
 Regular Expressions' which was  ported by Ze'ev Atlas.

 To assemble these programs you will need the supplied macros and will
 also need to assemble modules STRINGIT which is used in STRING macro
 and TRIMIT which is used by the TRIM macro.  Please refer to the
 JCLLIB that comes with the PCRE2 package for the appropriate JCL.
______________________________________________________________________

This code uses the following functions for the C environment

  EDCXHOTL    create C environment with library functions
  EDCXHOTU    call a C routine
  EDCXHOTT    terminate C environment

This method was chosen because the only example that I could find of
REXX calling C via assembler used this.
CEEPIPI may also work, and is recommended by IBM.  We may look at it
in subsequent releases.

See:-
Article "Calling C functions from Assembler - revisited"
by A Rudd printed in issue 208 of Xephon magazine of January 2004
http://www.cbttape.org/xephon/xephonm/mvs0401.pdf
______________________________________________________________________

It was thought that there were two distinct scenarios that the
use of PCRE from REXX would follow.

1, Parsing a value such as an argument to the REXX program or a
   single record in a control file.
2, Performing a regular expression on every record from a file.

To easily enable these two scenarios two versions of the interface
between REXX and PCRE were developed.

See #REXPCRE below for details of REXXPCRE.  For code example, see the
    #REXPCRE document in the PCRE2.ASM library in the distribution.
See #RXPCRE2 below for details of RXPCRE2.  For code example, see the
    #REXPCR2 document in the PCRE2.ASM library in the distribution.

The two main REXX functions are

REXXPCRE   -  the rexx function for single execution of the REGEX
              returns 0 - no matches
                      1 - matches
                      an error message


RXPCRE2    -  the rexx function for multiple executes of the REGEX
              this is the program which should be called from a
              rexx program to handle perl compatible regular
              expressions.
              It gets the rexx arguments and passes them to RXPCRE2A
              which is a separate load module which also contains
              the C code.
              On first call it loads RXPCRE2A into memory and returns
              the load address to the calling rexx function so that
              subsequent calls to this module can use the same
              version that was previously loaded.
              Returns from this function depend on the command given
              Any error messages from the program are written using
              a call to IRXSAY which is the 'SAY' callable function.

    'CONNECT'    connect to the C environment
                 returns eight bytes of environment information
                 or RC=8
    'COMPILE'    compile a regular expression
                 returns 19 bytes of compile information
                 or RC=8
    'EXECUTE'    run the regex using the input string, output
                 will go to the specified stem variable
                 returns 0 - no matches
                         1 - matches
                         8 - error
    'RELEASE'    remove the specified regex compilation
                 returns 0 - OK
                         8 - error
    'DISCONNECT' terminate the C environment
                 returns 0 - OK
                         8 - error

There are an additional four programs that are used by the above

RXPCRE2A   -  the sub-routine used by RXPCRE2 which contains the
              calls to all the C code and should only be called by
              RXPCRE2 as it uses the rexx environment that exists
              in that module.

PROCSTEM   -  a sub-routine that manipulates rexx stem variables on
              behalf of the calling program.
              Macro PRGSTEM should be used in the calling program
              to define the interface storage.
              This also makes use of the rexx environment.

STRINGIT   -  used by the STRING macro - acts like COBOL STRING.

TRIMIT     -  used by the TRIM macro to remove excess spaces.
______________________________________________________________________
#REXPCRE

 How REXXPCRE works.

   INPUT ARGUMENTS
     1, the PERL regular expression.
     2, the string to be worked on.
     3, a STEM name which will be populated with the output
     4, an optional OPTION
                    'g'  -  match all
                    'i'  -  ignore case
                    'x'  -  exclude white space
     5, an optional code-page - e.g.  'IBM-285'
        if omitted the default local page is used
     6, 'debug' if debugging required. Needs PCREDUMP DD name.

   OUTPUT
        if   successfull
             RC=1    matched  - stem contains output
             RC=0    no match - stem.0 will be '0'
        else
             RC='error message text'
        endif

   STEM variables output
        stem.0             count of stem variables
        stem.STRING.?      matched substrings
        stem.POS.?         position and length of matches e.g. 3,4
        stem.NAME.?        named substrings ' ' if none

   DEBUGGING can be done by specifying 'debug' as argument 6.
             You will also need to allocate the DD name PCREDUMP
             with DISP=MOD if more than one call to REXXPCRE
             because each call is a separate unit of work which
             includes opening and closing the dataset.

A brief discussion about code pages:
Various EBCDIC code pages place the dollar symbol in different code
points. In IBM-037 the dollar is x'5B' but in IBM-285 (UK) this is
the currency symbol for GBP and the dollar is at x'4A' which is the
cent symbol in IBM-037. Confusing!
Internally PCRE2 uses IBM-1047 so to use the dollar symbol in the
regex we pass a fifth argument which is the code page name we are
actually using.  This causes PCRE to convert the regex internally
from IBM-285 to IBM-1047 before it is compiled, similarly the string
is converted before the match is done.

NOTE - this argument is only required if you use a code page in your
terminal emulator which is NOT the same as the default local code page.
Normal processing by PCRE is to convert the REGEX and string from the
default local code page to IBM-1047.  IBM-1047 is used by the mainframe
C compiler.
*______________________________________________________________________
*
#RXPCRE2
  How RXPCRE2 works.

  This program RXPCRE2 is a rexx function and RXPCRE2A is a helper.
  On the 'connect' call RXPCRE2A is loaded into memory and the
  address of the program is returned, this enables the program to
  be found on subsequent calls.
  The 'disconnect' function terminates the C environment and deletes
  RXPCRE2A from memory.


  There are 5 calls to the function


  1, CONNECT
     Establish the C environment with or without debug.
     If OK returns an eight byte environment handle which should
     be used in subsequent calls to the function.
     An optional third parameter is the code page that is being used,
     this defaults to a z/OS environment variable but can be set
     byt the user.
     If DEBUG is specified then the DDNAME PCREDUMP must be allocated
     with DISP=MOD as the dataset will be opened and closed on
     every call.

     Returns 0 if OK
             8 if failed - an error message will be writen using IRXSAY

       r_c     = RXPCRE2('connect','pcre_env')
       r_c     = RXPCRE2('connect','pcre_env',,'debug')
       r_c     = RXPCRE2('connect','pcre_env','IBM-285')
       r_c     = RXPCRE2('connect','pcre_env','IBM-285','debug')

       if  r_c  > 0 then exit


  2, COMPILE (alias COMP)
     Compile a PCRE regular expression.
     This returns an nineteen byte compile handle which should
     be used in subsequent calls to the function.
     Options can be specified
                  'g'  repeat search
                  'i'  ignore case
                  'x'  exclude white space
     Note that multiple regular expressions can be compiled and
     then executed in turn.

     Returns 0 if OK
             8 if failed - an error message will be writen using IRXSAY

       reg_ex  = "(?<char>A)\g<char>"

       r_c     = RXPCRE2('compile',pcre_env,reg_ex,'pcre_comp','g')

       if  r_c  > 0 then exit


  3, EXECUTE or MATCH (alias EXEC)
     Process the compiled expression, repeat this call as required.
     The STEM name is used as the first part of the output
     'WANG' will give  WANG.0         the count of matches
                       WANG_STRING.?  the sub-strings
                       WANG_POS.?     the positions within the string
                       WANG_NAME.?    named sub-strings (blank if none)

     returns  0     no match - stem.string.0 will be '0'
              1     matched  - stem.string.? contains output
              8     an error message will be writen using IRXSAY

       the_str   = "AN_AARDWARK_JAKE_AND_AARDWARK_JACK"
       my_stem   = "WANG"

       r_c = RXPCRE2('execute',pcre_env,pcre_comp,the_str,my_stem)

     This call can be repeated as many times as required.


  4, SUBSTITUTE - alias SUBS
     This is similar to EXECUTE but uses the routine SUBSTIT2
     instead of MATCH2 and requires an additional input containing
     the substitute string.
     The variable name is used to contain the output string

     returns  0     no match - rexx variable not set
              1     matched  - rexx variable contains output string
              8     an error message will be writen using IRXSAY

       reg_ex      "cat|dog"
       the_str     "the dog sat on the cat's dog"
       subs_str    "horse"
       my_var    = "WANG"

       r_c = RXPCRE2('substitute',pcre_env,pcre_comp,the_str,,
                     my_var,subs_str)

     This call can be repeated as many times as required.


  5, RELEASE
     Release the compile storage
     Returns 0 if successfull.
             8 if failed - an error message will be writen using IRXSAY

       re_lease  = RXPCRE2('release',pcre_env,pcre_comp)


  6, DISCONNECT
     Terminate the C environment.
     Returns 0 if successfull.
             8 if failed - an error message will be writen using IRXSAY

       r_c     = RXPCRE2('disconnect',pcre_env)


  NOTE if any call fails then all storage and compile handles will
       be released and the C environment will be terminated.
       Do not attempt to continue after this.
*______________________________________________________________________
*
     STEM variables output
          stem.0             count of stem variables
          stem_STRING.?      matched substrings
          stem_POS.?         position and length of matches e.g. 3,4
          stem_NAME.?        named substrings ' ' if none

     these stem values will contain the same as stem.0
          stem_STRING.0
          stem_POS.0
          stem_NAME.0
*______________________________________________________________________
*
          PCRELIB

   When running in batch the LOAD macro will try to find the requested
   module/program object in the STEPLIB or JOBLIB concatenation
   which will contain the PDSE library containing RXPCRE2A. This works.

   In ISPF the library would be concatenated to ISPLLIB which will
   allow RXPCRE2 to be loaded, however, when this tries to load
   RXPCRE2A the STEPLIB would be used and would fail.
   It should be possible to put the program library in the ISPLLIB
   concatenation and amend all references to PCRELIB to ISPLLIB
   but this will not work when ISPLLIB is modified using LIBDEF as
   the library is not added to the actual ISPLLIB but to another
   DDNAME which is logically concatenated by ISPF.

   For the above reasons PCRELIB is used. If it is not present in the
   task IO table the program will not attempt to use it.

       /* allow RXPCRE2 to be loaded by REXX */
       "ISPEXEC LIBDEF ISPLLIB DATASET ID ('SDJRG.LOADLIB.POBJ')"
       if rc /= 0 then do
          say 'allocation to ispllib failed.'
          exit
       end
       /* allow RXPCRE2A to be loaded by RXPCRE2A */
       "ALLOC FI(PCRELIB)  DA('?????.LOADLIB.POBJ') SHR"
       if rc /= 0 then do
          say 'allocation to PCRELIB failed.'
          exit
       end

       ...

       "FREE FILE(PCRELIB)"
       "ISPEXEC LIBDEF ISPLLIB "
_____________________________________________________________________
 List of available error messages:
 (We will come with detailed explanations in subsequent releases)

RXPCRE2-001 - Error in set environment handle RC=
RXPCRE2-002 - Error in set compile handle RC=
RXPCRE2-003 - Could not find RXPCRE2A in PRCELIB
RXPCRE2-004 - Could not open PCRELIB
RXPCRE2-005 - Could not find RXPCRE2A
RXPCRE2-006 - Return code on SAY=
RXPCRE2-007 - invalid command specified
RXPCRE2-008 - command not specified
RXPCRE2-009 - command length was 0
RXPCRE2-010 - command greater than 20 bytes
RXPCRE2-011 - environment not specified as argument 2
RXPCRE2-012 - environment length was not 8 bytes
RXPCRE2-013 connect - debug command not 'debug'
RXPCRE2-014 compile - regex not specified
RXPCRE2-015 compile - regex length was 0
RXPCRE2-016 compile - regex not null terminated
RXPCRE2-017 compile - options > 20 bytes
RXPCRE2-018 compile - options were null terminated
RXPCRE2-019 compile - options not recognised
RXPCRE2-020 execute - argument compile result not passed
RXPCRE2-021 execute - argument compile result invalid
RXPCRE2-022 execute - string to test is missing
RXPCRE2-023 execute - string to test has zero length
RXPCRE2-024 execute - stem name not available
RXPCRE2-025 execute - stem name has 0 length
RXPCRE2-026 execute - stem name > 20 bytes
RXPCRE2-027 release - compile result not passed
RXPCRE2-028 release - compile result invalid length
RXPCRE2-029 connect - env handle not specified
RXPCRE2-030 connect - env handle length was 0
RXPCRE2-031 connect - env handle > 20 bytes
RXPCRE2-032 connect - env handle was DEBUG
RXPCRE2-033 connect - comp handle not specified
RXPCRE2-034 connect - comp handle length was 0
RXPCRE2-035 connect - comp handle > 20 bytes
RXPCRE2-036 connect - comp handle was DEBUG
RXPCRE2-037 subst - argument compile result not passed
RXPCRE2-038 subst - argument compile result invalid
RXPCRE2-039 subst - string to test is missing
RXPCRE2-040 subst - string to test has zero length
RXPCRE2-041 subst - variable name not available
RXPCRE2-042 subst - variable name has 0 length
RXPCRE2-043 subst - variable name > 20 bytes
RXPCRE2-044 subst - subs string not available
RXPCRE2-045 subst - subs string has 0 length
RXPCRE2-nnn - unknown error, RC=
RXPCRE2A-001 - Return code on SAY=
RXPCRE2A-002 - debug specified but DD name PCREDUMP not allocated
RXPCRE2A-003 - Invalid command
RXPCRE2A-004 - Max compiles exceeded
RXPCRE2A-011 - Ovector not big enough
RXPCRE2A-012 - Ovector not big enough
RXPCRE2A-013 - PCRE2 compilation failed at offset ...
RXPCRE2A-014 - Code page failure
RXPCRE2A-nnn - Unknown error, RC=
REXXPCRE-001 - REGEX (argument 1) not supplied'
REXXPCRE-002 - REGEX (argument 1) was zero length'
REXXPCRE-003 - STRING (argument 2) not supplied'
REXXPCRE-004 - STRING (argument 2) was zero length'
REXXPCRE-005 - STEM NAME (argument 3) not supplied'
REXXPCRE-006 - STEM NAME (argument 3) was zero length'
REXXPCRE-007 - STEM NAME (argument 3) > 20 bytes'
REXXPCRE-008 - OPTIONS (argument 4) > 20 bytes'
REXXPCRE-009 - OPTIONS (argument 4) not recognised'
REXXPCRE-010 - DEBUG (argument 6) <> 5 bytes'
REXXPCRE-011 - Output value longer than 2048'
REXXPCRE-012 - Return code on SAY='
REXXPCRE-013 - Matching error '
REXXPCRE-014 - PCRE2 compilation failed at offset '
REXXPCRE-015 - Code page failure (argument 5)'
REXXPCRE-016 - Debug specified but DD name PCREDUMP not allocated'
REXXPCRE-017 - Ovector not big enough'
______________________________________________________________________

10. Support functions
---------------------
The functions described here do not use Reg Exp because Reg Exp is not
yet available.  They help to prepare COBOL fixed length character
strings for Reg Exp manipulation.  COBOL character strings are
fundamentally different from C (and thus also C++, Java, C# and
virtually any other language) character strings in that they are fixed
length or length terminated (i.e. the length of the string is known
either in compile time or in run time via some variable.)  That length
is retrievable by means of querying the prefix variable or using the
LENGTH OF special register.  There is no terminator character (null or
otherwise.)  COBOL notion of fixed length or length terminated
character strings relates directly to the notion of fixed length
records - record length is pre-defined and known in similar manner and
there is no record terminator character.
Most other languages use the null terminated notation (i.e. the
end-of-string is signaled by the null character.  Regular Expression as
defined and implemented by Perl, Posix and PCRE depend on the string
being null terminated.  To add to the complication, C on z/OS adds
record terminator to the end of the record even on fixed length
records, but on text records, at least from the standard input, the
last spaces are chopped.  I coined that type as space terminated
records and strings.  Enterprise COBOL supports PIC Z strings which are
essentialy null terminated strings.
The functions herein provide the means to query a character string and
convert it to the desired format.  Note that to make a length
terminated string into null terminated one may use COBOL technique of
concatenating the sting with null:
           STRING YOUR-LENGTH-TERMINATED_STRING, LOW-VALUE
                  DELIMITED BY SIZE INTO YOUR-TARGET-STRING
Currently, these functions compile only under NATIVE_ZOS as I suspect
that nobody else will want or need them, however, it is pretty simple
to remove this limitation.

int pcrz_what_term_str (char * str, int maxlen); -
  Examines the string str for max length of maxlen and returns -1 if it
  is a null terminated, -2 if space terminated and -3 if length
  terminated.
int pcrz_is_space_term_str (char * str, int maxlen); -
  Examines the string str for max length of maxlen and returns -1 if it
  is a null terminated, -3 if length terminated and the actual
  significant length (i.e. sans the trailing spaces) if space
  terminated.
int pcrz_is_null_term_str (char * str, int maxlen); -
  Examines the string str for max length of maxlen and returns -2 if it
  is a space terminated, -3 if length terminated and the actual length
  if null terminated.
int pcrz_space_to_null_term_str (char * str, int maxlen); -
  Examines the string str for max length of maxlen.  If it is already
  null terminated, only the null terminated string part is examined
  farther.  The function looks for the last non-space character, marks
  the next character as null and returns the actual length of the null
  terminated string.  If the last non-space character is the last
  character (no room for null character, then the function will return
  -3 for length terminated.
  Note: maxlen is one more then the null terminated string length to
  allow for the null terminator.
int pcrz_null_to_space_term_str (char * str, int maxlen); -
  Examines  the string str for max length of maxlen.  If it is null
  terminated, the null character and all characters after it to maxlen
  are replaced by spaces.  The function then looks for the last
  non-space character and returns the actual length of the space
  terminated string.  If the last non-space character is the last
  character, then the function will return -3 for length terminated.
Note these two functions:
void FREEMAIN (void* ptr);
void * GETMAIN (size_t size); - GETMAIN and FREEMAIN are holdovers from
   PCRE.  The names were chosen because of the mainframe programmers
   familiarity with those names (as implemented in CICS) and because
   they are new development rather then an implementation of the PCRE
   functions (themselves meant as front ends for user implemented
   functionality.)
   GETMAIN and FREEMAIN are just front ends to the native C functions
   malloc and free.

11. GREP functionality
----------------------
GREP functionality is available through the pcr2grep module and is
working with added functionality not available in other OSes.  pcr2grep
for z/OS recognizes a PDS or PDSE as such and deal with it as if it was
a Unix directory.  All members are examined individually for the
searched pattern.  HFS and ZFS file systems are interpreted as they
should - as Unix file systems.
For some reason the z/OS Language Environment (LE) runtime is prompting
for its own runtime options.  Put '/' in the beginning of the
PARM='/... field to signal to LE runtime that it is not supplied with
any options.
Apparently, there is a difference in the way runtime options are
implemented in pcr2grep as opposing to, for example, pcr2test that does
not have this problem, but I have not yet find that difference.
There is a TESTGREP JCL member to demonstrate usage of pcregrep.
Note: #define NATIVE_ZOS_OFF
   Using this macro allows confining the effects of NATIVE_ZOS within
   the config.h so the rest of the program would compile without it.
   The main use of that is in PCR2GREP, if we want to ignore the
   effects of the z/OS specific file system and use it as pure Unix, or
   as a primitive OS if we also do not configure DEF(HAVE_SYS_STAT_H),
   DEF(HAVE_DIRENT_H) and DEF(HAVE_SYS_TYPES_H).
Testing of the full GREP functionality in z/OS/EBCDIC environment is
not complete (as of 10.22.544.) I will try to complete it for later
release.

12. Why isn't JIT Supported
---------------------------
This is a quote from Philip's email to me:
The JIT compiler compiles native machine code for the host it is
running on.  Zoltán has access to, and has provided code generators
for, several common non-mainframe architectures:

  ARM v5, v7, and Thumb2
  Intel x86 32-bit and 64-bit
  MIPS 32-bit
  Power PC 32-bit and 64-bit
  SPARC 32-bit (experimental)

Internally, the SLJIT compiler uses a generalized machine language that
combines the common elements of common architectures: this is then
refined for the actual architecture in use. I do not know whether it
would be possible to make it generate code for a mainframe, but that is
not really the point: the maintainer would have to have access to (and
familiarity with) a mainframe in order to implement it, and I very much
doubt that he has, or will ever have, this.
------
If any of you has the required expertise, you are welcome to join and
contribute.  Until then, JIT is not supported.

BTW, Philip was a mainframe programmer years ago and he still has no
intention to go for it :(

13. POSIX API in PCRE2
----------------------
Support for the POSIX API in PCRE2 was never meant to support the regex
model of POSIX, just to provide the user with the familiar API, but
with the PCRE2 (Perl Compatibility) regex model.  In order to prevent
undue conflicts in the binding (linkedit) step, I've decided to change
the API by providing PCRE2 specific names for the four POSIX functions.
The user is advised, of course, never to use the regex.h header in
conjunction with PCRE2 in order to prevent conflict in compile time
(for C.)
Users may, obviously, use the provided PCRE2 function names (and
include the POSIX module PC2POSIX in the binding step,) as is done
internally in PCRE2 for z/OS.  However to give the user the full beauty
of this functionality, the user may include the provided header file
PC2PSXAP.h (of four pragma map statements,) and continue to use the
native POSIX function names.  Remember that you need also the posixh.h
and the pcre2.h header files.  The provided IBMSAMPL.c program
demonstrates how to compile such programs with option to use either the
original POSIX functionality [UNDEF(COMPILE_WITH_PCRE2=1)] or the PCRE2
functionality [DEF(COMPILE_WITH_PCRE2=1)].  See the provided output
snippets below to demonstrate the difference.  For languages that do
not have pragma map or any equivalent, just use the PCRE2 function
names.  Use COMPIBMS in JCLLIB to compile IBMSAMPL either way.
Note that the provided API program, PCOBAPI2.c had a section that tried
to deal with the issue.  This section is now commented out and the
compile option UNDEF(NATIVE_ZOS_POSIX) does nothing.

Output snippets
---------------
+++ COMPILE WITH PCRE2 oneself
With the whole expression, a matched substring "oneself" is found at...
With the sub-expression, a matched substring "self" is found at...

+++ COMPILE WITH POSIX oneselfsufficient
With the whole expression, a matched substring "oneselfsufficient"...
With the sub-expression, a matched substring "selfsufficient" is...

14. Test Suite
--------------
1. While developing the test suite for EBCDIC we've corrected some bugs
   in the core PCRE2 regarding EBCDIC.  Only significant bugs and
   issues are mentioned.
   1.1 \c is now behaving as described in the perlebcdic document.
   1.2 \a and \e are translated across the board to 0x2f and 0x27
      rather than to the ASCII designations 0x07 and 0x1b.
2. There are some differences in between ASCII and EBCDIC.
   2.1 The aforementioned \c is limited to 32 characters only (see
      Perlebcdic).
   2.2 The \h meta-character includes 0x09 (tab), 0x20 (space) and 0xa0
      (non-breaking space).  In EBCDIC \h now includes the parallel
      0x05 (tab), 0x40 (space) and 0x41 (non-breaking space).
   2.3 The \R, \v meta-characters include 0x0a, 0x0b, 0x0c, 0x0d and
      0x85, which corresponds perfectly with the EBCDIC equivalents,
      0x0b, 0x0c, 0x0d, 0x15 and 0x25, but the latter misbehaves.  OTH
      most people would never use 0x25 for nothing so it is a moot
      issue.
   2.4 Perl recognizes the [A-Z] and [a-z] as special cases that
      include the letters a-z and A-Z only, without the EBCDIC gaps.
      This is implemented in PCRE2 only.
3. Test suites
   In developing the EBCDIC test suite, I used this Methodology:
   3.1 We are interested only in testinput1, testinput2, testinput15,
      testinput16, testinput18, testinput20 and testinput21.  In the
      past we were interested partially in the old testinput11 and
      testinput14.
   3.2 I Compared pcr2test results from the provided standard test
      suite to the z/OS EBCDIC results (after converting to ASCII.)
   3.3 I ignored all same results or where the differences were obvious
      (0x0a vs. 0x15, Caret vs. logical not) and where the EBCDIC
      results are matching correctly, if different.
   3.4 For all remaining issues, I've developed a small test suite that
      either demonstrates how to code the pattern so that it would
      match, demonstrates significant point of difference, or overcome
      issues such as  different file name scheme (for saved regexes),
      etc.
   3.5 The provided files are ASCII images of the actual EBCDIC files.
      The original EBCDIC files would be available on the EBCDIC
      distribution on the PCRE2.TESTLIB library.
      TSTINE1 - derived from issues in testinput1.
      TSTINE2 - derived from issues in testinput2.
      TSTINE11 - derived from issues in testinput11.
      TSTINE14 - derived from issues in testinput14.
      TSTOTE1 - pcretest z/OS output for TSTINE1.
      TSTOTE2 - pcretest z/OS output for TSTINE2.
      TSTOTE11 - pcretest z/OS output for TSTINE11.
      TSTOTE14 - pcretest z/OS output for TSTINE14.
      All in addition to the existing :
      TSTIN1 - EBCDIC for testinput1.
      TSTIN2 - EBCDIC for testinput2.
      TSTIN15 - EBCDIC for testinput15.
      TSTIN16 - EBCDIC for testinput16.
      TSTIN18 - EBCDIC for testinput18.
      TSTIN20 - EBCDIC for testinput20.
      TSTIN21 - EBCDIC for testinput21.
      TSTOT1 - EBCDIC images of the original (ASCII) test outputs.
      TSTOT2
      TSTOT15
      TSTOT16
      TSTOT18
      TSTOT20
      TSTOT21
      TSTOO1 - EBCDIC test outputs from the PCRE2 for z/OS.
      TSTOO15
      TSTOO16
      TSTOO18
      TSTOO2
      TSTOO20
      TSTOO21
      Note: the output compiled patterns are not provided.  This
         decision may change if there is some popular demand :)
      Note: TSTIN20 fails because it tries to save patterns Unix style.
      Changing the file names from testsevedn to test.savedn
   corrects it.
      This facility is also tested in TSTINE2/TSTOTE2.

15. Excerpts from previous versions comments
--------------------------------------------
1. Posix compatibility is now available, but the routine names are NOT
   the standard Posix routine name to prevent any conflict.
2. The COBOL library contains a COBOL module, REGEX1 that demonstrate
   how to use the standard IBM supplied Posix routines.  This module
   was adapted to COBOL by Mr. Frank Swarbrick and is published here
   with his permission.  To compile this program use COMPREGX in
   JCLLIB.
3. The C compiler options are supplied in the JCL via OPTFILE file.
   This allows of controlling user supplied compile time options by
   using something like DEF(SOME_DEFINITION) akin to -D in Unix.  Using
   this option reduced significantly the need to perform source code
   changes which might be tricky even if performed by an automated
   process.
4. This version does not (yet) know how to take a pattern (wildcard)
   for filename or membername.
5. While a few people have expressed interest in the PL/I interface and
   some tried to give me useful advice, I've found that with my limited
   time and resources, I cannot do it.  Hence, PL/I support is
   officially dropped and will not be renewed unless there would be a
   volunteer who is both capable in working with PL/I and its
   interfaces, and is ready to devote time for this project.
6. REXX seemed to me to be a perfect fit for PCRE.  It is analogous to
   Perl in the native z/OS ecosystem and is doing similar (though much
   more primitive) pattern matching.  However, the REXX interface is
   extremely involved and working with it requires expertise that I do
   not posses and do not have the time to acquire, and that despite of
   useful advice from some people.  Hence, no REXX support is planned
   unless there would be a volunteer who is both capable in working
   with REXX and its interfaces, and is ready to devote time for this
   project.
7. A message to users who choose to download from CBTTAPE:
   You do not need the full installation package (which is in ASCII) if
   your installation is using IBM-037.
   Filexxx is a full version of the PCRE2 port, all in EBCDIC and
   PDS/E, intended to save the end user the hassle of uploading ASCII
   files while converting to EBCDIC and the hassle of creating the
   appropriate libraries.  Once you upload FILExxx.XMI (in binary
   mode),    perform the necessary 'RECEIVE' of the installation
   library and then    the RECEIVE for the various libraries, you have
   the full source code    and even the LOADLIB (if you use IBM-037).
   If you want the ASCII version for whatever reason, you may download
   it from www.zaconsultants.net.
------------
16. Why separate POSIX routine names:
-------------------------------------
The build (compile and link or bind) on the mainframe is much more
primitive then what you have on either Unix/Linux or Windows.  I
created my own process that compiles the modules twice, first time
deliberately with no dependency resolution.  Then I take the compile
output (SYSOUT:) and analyze it to create dependency resolutions
based on 'missing' and 'found' names, before I compile to
completion.

This works fine, but I forgot that the POSIX routine names are standard
and thus available at the lowest level of  dependency resolution,
unless I integrate the PCRE library in the system available libraries
ahead of the standard run-time libraries, which I forgot to do (even
though I put a glaring warning in my own documentation months ago!)

Judging from my own error, I assume that others would do it as well.
I decided to add the Posix routine names to those names that I change
anyway (upper case. 8 characters only, no underscore.)  I thus
separated the standard Posix routine from PCRE Posix routines names.
For the people and culture around z/OS, this is probably the best
solution.  This required basically changing few parameters in my data
(and very minor adjustment in a couple of scripts) and wasn't that
hard.
